# 模板

## 1、问题

​	在编程过程中，有时会发现两个类（函数）处理的数据类型不一样，但代码是一样的，这个时候若重新声明一个类（函数），会显得多余，怎么办？

## 2、解决方案：

- 方案一：使用`typedef`来处理。这种方法的局限性是，每次修改类型时都需要编辑头文件，在每个程序中只能使用这种技术生成一种栈。

- 方案二（模板）：编写一个泛型栈（独立于类型的栈），然后将具体的类型作为参数传递给这个类（函数），这样可以使用通用的模板来生成存储不同数据类型值的栈。

## 3、编程思想

​		GP（Generic Programming）



# 函数模板

## 1、简介

- 函数模板是通用的函数描述，也就是说，他们使用泛型来定义函数，通过将类型作为参数传递给模板，可使编译器生成该类型的函数。
- 由于类型是用参数来表示的，因此模板特性有时也被称为参数化类型（parameterized types）。
- 模板并不创建任何函数，而只是告诉编译器如何定义函数，最终的代码中不包含任何模板，而只包含了为程序而生的实际模板（模板函数）。因此，常见的情形是将模板放在头文件中，并在需要使用模板的文件中包含头文件。
- 可以像重载常规函数定义那样重载模板定义，和常规重载一样，被重载的模板的函数特征标必须不同。



## 2、函数模板定义

### 2.1、常规模板定义：

```c++
template <typename/class T>	// 告诉编译器，要创建一个模板，类型名为 T
void swap(T &a,T &b){
    T temp;
    temp = a;
    a = b;
    b = temp;
}
```

### 2.2、显式具体化（explicit specialization）模板定义

#### 2.2.1、问题

​	有时，编写的模板函数很可能无法处理某种类型（加法对于结构体），这时候需要为特定类型提供具体化的模板定义。

#### 2.2.1、声明

​	`template <> void swap<T>(T &a, T &b);	// <T>可省`

### 2.3、模板优先级

- 对于给定的函数名，可以有非模板函数，模板函数，显式具体化模板函数和他们的重载版本。
- 非模板函数优先于具体化和模板函数，具体化优先于模板函数。



## 3、实例化

### 3.1、什么是实例化

​	编译器使用模板为特定的类型生成函数定义时，得到的是模板实例，这个过程称为实例化（instantiation）。

### 3.2、实例化的种类

#### 3.2.1、隐式实例化（implicit instantiation）:

```c++
template <typename/class T>
void swap(T &a,T &b){
    T temp;
    temp = a;
    a = b;
    b = temp;
}
int a = 0;
int b = 1;
swap(a,b);	// implicit instantiation
```

​		程序调用`swap()`时提供了`int`参数，所以编译器才知道需要进行定义。

#### 3.2.2、显式实例化（explicit instantiation）：

`template void swap<int>(int, int);	// explicit instantiation`

编译器看到声明后，将使用`swap()`模板生成一个使用`int`参数的实例。

#### 3.2.3、显式实例化和显式具体化的比较

1. 声明方式：

    ```c++
    template <> void swap<int>(int, int);	// <T>可省，显式具体化
    template void swap<int>(int, int);	// explicit instantiation
    ```

2. 作用：

    - 实例化告诉编译器，用普通模板生成一个模板函数。
    - 具体化告诉编译器，不要用普通模板，要创建一个特殊模板。

3. 试图在同一个文件（或转换单元）中使用同一种类型的显式实例和显式具体化将出错。

### 3.3、重载解析（overloading resolution）

#### 3.3.1、什么是重载解析？

​	对于函数重载，函数模板和函数模板重载，C++需要一个良好的策略，来决定为函数调用使用哪个函数定义，尤其是有多个参数时，这个过程成为重载解析。

#### 3.3.2、过程

1. 创建**候选函数列表**。其中包含与被调用函数的**名称相同**的函数和模板函数。
2. 使用候选函数列表创建**可行函数列表**，这些都是**参数数目**正确的函数，为此有一个隐式转换序列。注意，只考虑特征标，而不考虑范围类型。
3. 确定是否有最佳的可行函数。如果有，则使用它，否则，报错。

#### 3.3.3、匹配时转换的优先级

1. **完全匹配** ，但常规函数优先于模板；
2. 提升转换；
3. 标准转换；
4. 用户自定义的转换；

#### 3.3.4、完全匹配的注意事项

- 进行完全匹配时，C++允许某些无关紧要的转换。
- 通常，有两个函数完全匹配是一种错误，但这个规则有一两个例外。
    1. 指向非`const`数据的指针和引用**优先**与非`const`指针和引用参数匹配。
    2. 非模板函数优先于模板函数。
    3. 如果两个完全匹配的函数都是模板函数，则**最具体**（执行的转换最少）的模板函数优先。
- 部分排序规则（partial ordering rules）：用于找到最具体的**模板**的规则。
- 将有多个参数的函数调用与有多个参数的原型进行匹配时，情况非常复杂。一个函数要比其他函数都合适，其所有参数的匹配程度都必须不必其他函数差，同时至少有一个参数的匹配程度比其他函数高。

### 3.4、判断数据类型（c++11/14）

#### 3.4.1、关键字`decltype`

##### 3.4.1.1、问题

```c++
template <class T1,class T2>
void add(T1 a,T2 b){
    z = a + b;	// z是什么类型
}
```

##### 3.4.1.2、解决方案

- 关键字`decltype`：可以用于确定 z 的**数据类型**。
- 例子：
    1. `int x;   decltype(x) y;	// make y type as the same as x`
    2. `decltype(x+y) z;  z = x+y;   //make z type as the same as x+y`

- 为确定类型，编译器必须遍历一个核对表，步骤如下：（`decltype(expression) var`）
    1. 如果`exprassion`是一个没有用括号括起来的标识符，则`var`的类型与该标识符的类型相同，包括`const`等限定符。
    2. 如果`exprassion`是一个函数调用，则`var`的类型与函数的返回类型相同。
    3. 如果`exprassion`是用括号括起来的标识符，且`exprassion`是一个左值，则`var`为指向其类型的引用。
    4. 如果前面的条件都不满足，则`var`的类型与`exprassion`的类型相同。

#### 3.4.2、后置返回类型（trailing return type）

##### 3.4.2.1、问题

```c++
template <class T1,class T2>
type gt(T1 x,T2 y){
    return x+y;
}	// 函数返回值是什么类型
```

##### 3.4.2.2、解决方案

- 函数声明改写为 `auto function()->returnType`
- 例子：

```c++
template <class T1,class T2>
auto gt(T1 x,T2 y) -> decltype(x+y)
{
    return x+y;
}
```





# 类模板

## 1、定义

### 1.1、定义

- `template <typename type>`；`typename`可看成变量的类型名，`type`可看成变量名，它接受类型作为其值。
- 采用模板时，将使用模板定义替换类声明，使用模板成员函数替换类的成员函数，将类限定符从`className::`改成`className<Type>::`，每个函数头都将以相同的模板声明打头。
- 由于模板不是函数，他们不能单独编译，模板必须与特定的模板实例化请求一起使用，因此，最简单的方法是将所有模板信息放在一个头文件中，并在要使用这些模板的文件中包含该头文件。

### 1.2、参数说明

​	`template <typename T,int n>`

- 类型参数：赋给他们的只能是类型；`T`
- 非类型（或表达式）参数：`n`
    1. 表达式参数可以是整型，枚举，引用或指针，使用时有一些限制。
    2. 会生成多个类声明。

### 1.3、注意

- 使用所需的具体类型来替换泛型名。
- 必须显式地提供所需的类型，与函数模板不同，编译器可以解决。



## 2、具体化（specialization）

### 2.1、隐式实例化

​	`className<string,100>;`

​	声明一个或多个对象，指出所需的类型，而编译器使用**通用模板**提供的处方生成具体的类定义。编译器在需要对象之前，不会生成类的隐式实例化。

### 2.2、显式实例化

​	`template class className<string,100>;`

​	声明必须位于模板定义所在的名称空间中。在这种情况下，虽然没有创建或提及类对象，编译器也将生成类声明（包括方法的定义）。

### 2.3、显式具体化

​	`template <> class className<specialized-type-list>;`

​	与函数模板的具体化定义类似。

### 2.4、部分具体化（限制模板的通用性）

​	`template <class T1> class className<T1,int>;`  

​	`T1`是没被具体化的参数，若`template`后的<>为空，则变成显式具体化。

- 如果有多个模板可以选择，编译器将选择使用**具体化程度最高**的模板。

## 3、类模板和其他

- 可以将常规类的技术用于模板类，模板类可以作基类，可作组件类（结构，类，模板类的成员），也可作其他模板的类型参数。

- 成员模板：

    

- 模板参数：

    

- 友元：



