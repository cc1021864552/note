# 一、内存模型

- 根据用于分配内存的方法，C++用3种管理数据内存的方式：自动存储，静态存储和动态存储（有时也叫作自由存储空间或堆），C++11新增了第四种类型——线程存储。
- 不同的C++存储方式是通过存储持续性、作用域和链接性来描述的。
    1. 作用域（scope）：描述了名称在文件（翻译单元）的多大范围内可见。
    2. 链接性（linkage）：描述了名称如何在不同单元间共享。



## 1.1、自动存储持续性

- 在程序开始执行其所属的函数和代码块时被创建，在执行完函数或代码块时，他们使用的内存释放。

- 作用域为局部，没有链接性。
- 两个关键字：`auto` 和 `register`
    1. `auto`：用于自动类型推断；
    2. `register`：显式的指出变量是自动的；
- 定义掩盖



## 1.2、静态存储持续性

- 在程序运行的整个过程中都存在，编译器将分配固定的内存块来存储所有的静态变量。

### 1.2.1、初始化：

- 静态初始化：编译器在处理文件时初始化变量
    1. 零初始化：未被初始化的静态变量的所有位都被设置为0；
    2. 常量表达式初始化：字符常量的算数表达式，`sizeof`运算符等；

- 动态初始化：变量在编译后初始化

- 初始化优先级：所有的静态变量都被零初始化，接下来，如果使用了常量表达式且编译器可以计算出来，则进行常量表达式初始化，如果没有足够的信息，变量将被动态初始化。

```c++
#include <cmath>
int x;
int y = 5;
int z = 13*13;
const double p = 4.0*atan(1.0);	// 动态初始化
```



### 1.2.2、外部变量（全局变量）：

- 链接性为外部（外部），作用域为整个文件（全局）。

- 变量声明：

    1. 定义声明（defining declaration）：给变量分配存储空间。

        `int down = 1; int left; extern int up = 1;`

    2. 引用声明（reference declaration）：不会给变量分配存储空间，它引用已有的变量。

        `extern int up;`

- 单定义规则并非意味着不能有多个变量的名称相同，但每个变量都只有一个定义。

- 同名自动变量可以掩盖外部变量，可以将`::`放在变量前，表示使用的是变量的全局版本。

- 用途：可用于在不同文件间分享数据。



### 1.2.3、静态变量：

1. 链接性为内部，作用域为整个文件。

2. 声明：`static int a;`

3. 静态变量和外部变量：

    - 静态变量与外部变量名称相同，则在定义静态变量的文件中，静态变量将隐藏外部变量。
    - 没有违反单定义规则，因为链接性不同。

4. 用途：可用于在同一个文件的不同函数间分享数据。

    

### 1.2.4、局部变量：

1. 无链接性，作用域为局部。
2. 声明：将`static`限定符用于在代码块中定义的变量。
3. 该变量只会被初始化一次，在该代码块不活跃时依然存在。
4. 用途：



### 1.2.5、c-v限定符

- `const`

    1. 表明，内存被初始化后，程序便不能再对其进行修改。
    2. `const`限定符对默认的存储类型有影响，再默认情况下全局变量的链接性是外部，但`const`全局变量的链接性是内部，即好像使用了`static`。
    3. 可以用`extern`来将常量链接性拓展到外部，在函数或代码块中声明`const`时，其作用域为代码块。
    4. 用途：可以将常量定义放在头文件中，这样每个包含头文件的源文件都会拥有自己的常量组，而不是共享一组常量。

- `volatile`

    

- `mutable`



## 1.3、动态存储持续性（`new`和`delete`）

- 动态内存由`new`和`delete`控制，而不是由作用域和链接性规则控制，因此，可以在一个函数中分配动态内存，而在另一个函数中释放。

- 虽然存储方案概念不适用于动态内存，但适用于用来跟踪动态内存的自动和静态指针变量。

    `float * p = new float[10];` ；`new`出来的内存一直存在，直到被释放；而 p 在包含该声明的语句块结束后就被释放。

### 1.3.1、`new`

#### 1.3.1.1、普通`new`

- 初始化：

    1. `int *p = new int(6);`该方法也适用于类。

    2. ```c++
        struct where{
            int x;
            int y;
        };
        where * p = new where{1,1};   // 结构体初始化
        
        int *p = new int[4]{1,1,1,1};  // 数组初始化
        ```

- 初始化失败：引发异常 `std::bad_alloc`

#### 1.3.1.2、定位`new`

- 作用：可以让我们能指定要使用的位置。



### 1.3.2、`new`与`class`

- 如果在构造函数中使用`new`来初始化指针成员，则应该在析构函数中使用`delete`；
- `new`和`delete`必须兼容，如果有多个构造函数，必须以相同的方式使用`new`；
- 继承和`new`：
- 派生类如何使用基类的友元：





# 二、名称空间

- 为什么要引入名称空间？

    ​	在使用多个类库时，可能发生名称冲突的问题，引入命名空间，可以更好地控制名称的作用域。C++关于全局变量和局部变量的规则定义了一种名称空间层次。

- 已有的空间名词：

    1. 声明区域（declaration region）：可以进行声明的区域。
    2. 潜在作用域（potential scope）：从声明点开始，到其声明区域的结尾。
    3. 作用域（scope）：变量对程序而言是可见的范围被称为作用域。

- 新增的名称空间：

    1. 提供一个声明区域；
    2. 一个名称空间中的名称不会与另一个名称空间中的相同名称发生冲突；
    3. 允许程序的其他部分使用该名称空间中声明的东西；

- 声明：关键字`namespace`

    1. 在默认情况下，在名称空间中声明的名称的链接性为外部的（除非它引用了常量），可通过`::`来访问空间中的名称。

    2. 名称空间中的声明和定义规则同全局声明和定义规则相同。

    3. 空间是开放的，可以将名称加入到已有的名称空间中。

        ```c++
        namespace Jill{
            char * goose();	//将goose()加入到Jill中
        }
        ```

    4. 可以将函数原型放在一个空间中，然后再该文件后面后者在另一个文件中再次使用同一个名称空间来提供该函数的代码。

    5. 除了用户定义的名称空间外，还有一个名称空间（全局名称空间），全局变量被描述为位于这个空间中。

- `using`声明和`using`编译指令
    1. 不用每次使用时都对名称进行限定。
    2. `using`声明使特定的标识符可用，将特定的名称添加到它所属的声明区域（局部，全局）。
    3. `using`编译指令使整个名称空间可用，使空间中的所有名称可用（全局，局部）。
    4. 二者增加了名称冲突的可能性。
    5. 二者的差别：
        - 编译指令更像是大量的使用域解析运算；
        - 声明更安全；













