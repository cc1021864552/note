# Memory Management



## 一、OS眼中的内存

​	现实世界中，内存是一种存储设备，一般由DRAM组成，掉电后信息丢失。但在OS眼中，内存被抽象成了一个巨大的线性字节数组，每个字节都有自己的地址。CPU根据地址来读写内存中的相应单元，内存单元不知道地址是如何产生的。

​	内存存在的意义是作为进程的容器，同时保存多个进程，以便多道程序的运行。

​	在内存管理中，**地址**是个很重要的概念。地址的类型，地址的转换，地址的产生，分配都是很重要的问题。



## 二、由硬盘进入到内存

### 2.1、内存空间的保护	

​	CPU不能直接访问磁盘，因此，程序必须被加载进内存才能被CPU执行，完成相应的功能。前面说过，OS眼中的内存是一个有地址的字节序列，所以，当程序进入内存后，命令序列也就有了地址。问题是，CPU可以随意访问这些地址吗？

​	答案是不可以。当CPU执行某个程序的某个指令时，从用户的角度看，就是这个程序正在执行。两个不同的程序在执行时可以随意访问对方的代码和数据吗？出于安全性的考虑，不行。因此，必须为每一个程序在内存中分配一个独立的空间，并保证别的进程不能访问。这称为**内存空间的保护**。

​	内存空间的保护是通过CPU硬件对在用户模式下产生的地址和寄存器的地址（基址和界址）进行比较来完成的，用户进程无法修改这两个寄存器的值。只用操作系统可以通过特殊的特权指令才能加载基址和界址寄存器。当非法访问发生时，会陷进操作系统，然后被处理。

### 2.2、地址绑定

​	前面说过，当程序进入内存时，会给其分配地址，这称为**地址绑定**。在程序编译运行的过程中，地址的形式会发生变化，在源码阶段，地址通常以变量的形式存在；在编译时，变量地址通常被绑定到可重定位地址；而链接和加载阶段，这些可重定位地址被绑定到绝对地址。

​	由此可知，程序最终在内存中的地址可以在三个不同的时间点确定，分别是：编译时（compile time），加载时（load time），运行时（runtime time）。

​	大多数操作系统采用运行时方案，采用这种方案需要特定的硬件才行。

### 2.3、地址

​	CPU生成的地址和内存单元看到的地址（内存地址寄存器）可能不一样，前者称为逻辑地址，后者称为物理地址。

​	在编译时地址绑定和加载时地址绑定的模型中，逻辑地址和物理地址是一致的，而在运行时绑定地址的模型中，二者一般不一致，这时，需要一个硬件设备来进行转换。这个硬件就是**内存管理单元（MMU）**。

​	问题是，MMU如何转换这两种地址？



## 二、内存分配

​	内存通常分为两个区域：一个用于驻留OS，一个用于用户进程，OS的存放位置取决于中断向量的位置。在OS分配内存时，应该要知道内存的使用情况，即哪块正在被使用，哪块处于空闲状态，并且，需要实时更新这些数据。若有多块内存空间符合分配条件，OS还要决定分配哪一块，这被称为**动态存储分配问题**。解决动态存储问题的思想有几种：首次适应，最优适应，最差适应。

​	在分配的过程种，还有一个问题要重视，即**内存空间的使用效率**。为了尽可能的提高使用效率，人们想出了几种方法：连续内存分配，分段，分页以及他们的结合。

### 2.1、动态存储分配问题

- 首次适应：分配首个足够大的块。
- 最优适应：分配最小的足够大的块。
- 最差适应：分配最大的块，性能比较差。

### 2.2、内存空间的使用效率

​	关于内存空间的分配，一个最直观的想法是，将每个程序分配到一块连续的内存空间。这足够直观，但会产生较严重的浪费，即会产生很多没办法再次利用的**外部碎片**。解决碎片问题有两种可行的方法，一种是移动碎片，将所有的空闲空间拼在一起使用，称为**紧缩**；还有一种是允许进程的逻辑地址空间是不连续的。紧缩并非总是可行的，取决于地址绑定的方式。后一种方法衍生出了下列两种方案。

#### 2.2.1、分段

- OS将内存看作一个一维的字节数组，而程序员却不这么看，他们将内存看作一组不同长度的段，这些段之间没有一定的顺序。分段是一种支持用户视角的内存管理方案。
- 这种方案下，逻辑地址由一个元组（段号，段内偏移）构成，物理地址还是一个一维地址，这二者之间的转换由段表完成，**段表**由表项（界限，段的物理基地址）组成。

#### 2.2.2、分页（重点）

- 将物理内存和逻辑内存分为**同样大小，固定大小**的块，分别称为帧（frame）和页（page）。
- 逻辑地址和物理地址之间的转换由页表完成，逻辑地址由元组（页码，页内偏移）组成，**页表**由表项（页号，帧号）组成。
- 分页通过有效无效位来实现内存的保护，操作系统可以通过这个位，来捕捉非法地址。
- 注意到，分页本身是一种动态的重定位，页表充当重定位寄存器的集合。
- 分页允许物理内存空间大于逻辑内存空间，操作系统通过**帧表**了解物理内存的使用情况，即知道哪些帧已分配，哪些帧空闲，总共有多少帧等等。
- 每个进程维护自己的一张页表，操作系统维护每个进程的页表的副本，这个副本用于地址的转换和进程的切换，因此，分页增加了上下文切换的开销。

#### 2.2.3、分页的硬件支持

- 放在寄存器中

    ​	当页表表项数目比较少时，可以采用。

- 放在内存中，将页表基址寄存器（PTBR）指向页表。

    ​	会增加访存时间次数（1->2）从而影响效率。

- 放在缓存（TLB）和内存中

    ​	TLB只保留少量的表项，需要访问页表时，先访问TLB，若未命中，再访问内存。**TLB是一个硬件功能，因此OS并不关心？**

#### 2.2.4、页表的结构

- 分层分页
- 哈希分页
- 倒置分页

#### 2.2.5、分段和分页的区别

- 分段是从程序员的角度看待内存空间的，而分页是从OS的角度看待内存的，前者更加重视内存空间的直观与否，而后者则更加重视内存的使用效率。
- 分段不保证段的大小一致，而分页保证页和帧的大小一致。分页的这种保证，方便内存分配的执行，也可解决外部碎片问题。



## 三、内存和外存之间的交换

